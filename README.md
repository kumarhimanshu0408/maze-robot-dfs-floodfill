# maze-robot-dfs-floodfill

## üß± Maze Creator GUI (`maze_creator.m`)

This project includes a **Maze Creator GUI** that allows you to visually design **any N√óN maze** by clicking to add or remove internal walls.
The output generated by the GUI can be used **directly** in the main maze-solver script.

### ‚úÖ Features of the GUI

* Clickable grid interface to toggle walls.
* Internal walls are shown in **red** when active.
* Automatically maintains **correct wall symmetry** (`maze(r,c,:) = [N E S W]` format).
* Outer boundary walls are included automatically.
* Allows selection of **start** and **goal** cell positions.
* Outputs ready-to-paste MATLAB code to the **Command Window**.

---

### üß© How the GUI Works

| Function                                | Role                                                                                    |
| --------------------------------------- | --------------------------------------------------------------------------------------- |
| `setupAxes(ax, N)`                      | Creates an N√óN grid and sets consistent top-left coordinate frame.                      |
| `drawWalls(ax, N)`                      | Draws all possible **internal wall segments** and registers them as click-able objects. |
| `toggleWall(src, ~)`                    | Toggles wall state and color when clicked (Gray ‚Üí Red ‚Üí Gray).                          |
| `generateMazeCode(h_walls, v_walls, N)` | Reads current wall configuration and prints valid MATLAB maze definition code.          |

#### Wall Encoding (Matches Solver Format)

Each maze cell stores four binary values:

[
\text{maze}(r,c,:) = [N; E; S; W]
]

| Value | Meaning     |
| ----- | ----------- |
| `1`   | Wall exists |
| `0`   | Open path   |

Example generated wall code:

```matlab
maze(2,3,3)=1; maze(3,3,1)=1;   % Wall between (2,3) and (3,3)
maze(4,1,2)=1; maze(4,2,4)=1;   % Wall between (4,1) and (4,2)
```

This output can be **copied directly** into the main solver script.

---

### üîó Using GUI Output in the Solver (Step-by-Step)

1. Run the GUI:

   ```matlab
   createMazeGUI;
   ```
2. Toggle walls as desired.
3. Click **Generate Maze Code**.
4. Copy the printed maze configuration.
5. Paste it into the **MAZE DEFINITION** section of the solver script.
6. Adjust:

   ```matlab
   startCell = [row, col];
   goalCell  = [row, col];
   ```
7. Run the solver ‚Äî the robot will:

   * **Explore** the maze using **Depth-First Search (DFS)**.
   * Build its own internal map (`robot_map`) through **local sensing**.
   * Use **Flood-Fill (BFS)** to compute **shortest path**.
   * Drive continuously using **real motion kinematics**.

---

## ü§ñ Robot Kinematics & Motion Control

The robot is modeled as a **unicycle robot** with continuous state:

[
\mathbf{p} =
\begin{bmatrix}
x \ y \ \theta
\end{bmatrix}
]

Where:

* (x, y) = position in meters
* (\theta) = heading angle (radians)

### üéØ Targeting the Next Cell Center

Target cell center:
[
(x^*, y^*)
]

Distance and bearing to target:
[
\rho = \sqrt{(x^* - x)^2 + (y^* - y)^2}
]
[
\theta^* = \text{atan2}(y^* - y, x^* - x)
]
[
\alpha = \text{wrapToPi}(\theta^* - \theta)
]

### ‚öôÔ∏è Control Inputs

[
v = K_{\rho} \cdot \rho \cdot \mathbb{1}*{(|\alpha| < \pi/2)}
]
[
\omega = K*{\alpha} \cdot \alpha
]

This ensures the robot **moves forward only when mostly facing the target**.

### üöó Motion Update (Discrete Time)

[
x_{k+1} = x_k + v \cos(\theta_k), dt
]
[
y_{k+1} = y_k + v \sin(\theta_k), dt
]
[
\theta_{k+1} = \text{wrapToPi}(\theta_k + \omega, dt)
]

### ‚úÖ Same Controller Used For:

| Phase                   | Motion Type                               |
| ----------------------- | ----------------------------------------- |
| Exploration (DFS)       | Move cell-to-cell while discovering walls |
| Shortest Path Execution | Follow the optimal path from Flood-Fill   |

This results in **smooth, realistic movement** through the maze.

---

## üèÅ Summary

| Component               | Purpose                                        |
| ----------------------- | ---------------------------------------------- |
| Maze Creator GUI        | Allows custom mazes to be created visually     |
| DFS Exploration         | Robot learns maze by sensing only what it sees |
| Robot Map (`robot_map`) | Stores discovered wall information             |
| Flood-Fill              | Computes shortest path from Goal back to Start |
| Kinematic Controller    | Ensures smooth robot motion at all times       |

---

### üéâ Result

Your project now supports:

* Any **N√óN custom maze**
* Realistic robot movement
* Autonomous mapping + path planning
* Fully visualized solver

---

Just tell me:
**Do you want the README style to be *simple* or *professional showcase*?**
